#### computed 를 사용해 선언한 변수가 내부에 들어가 있는 값이 변경됨에도 computed 반응하지 않는 문제 발생

#### ! computed 가 반응하는 시기
1. computed 내부에서 사용된 ref 로 선언된 변수의 .value가 변경될 때,
2. computed 내부에서 사용된 reactive로 생성된 객체의 속성 값이 변경될 때, -> 안됨
3. computed 내부에서 사용된 다른 computed 속성의 값이 변경될 때
위 세 경우에 computed 속성이 재 계산된다.


#### 문제점
- 현재 프로젝트의 경우, ref로 반응성 관리를 하고 있는데, 
  ref 를 사용해 선언한 변수가 변경되어도 해당 computed 가 작동하지 않아서 Select box 를 통한 값 변경에도 Chart 정보 변경이 되지 않는 문제 발생

#### 원인
- **깊은 중첩과 반응성 추적의 한계**
	- 현재 변경을 추적하고자 하는 값은 SelectBox 객체로, select 된 value 에 접근하기 위해서는 .value.value 와 같이 두 번의 .value 접근을 통해 값을 얻을 수 있다.
	- 하지만, Vue의 반응형 시스템은 기본적으로 객체 속성에 직접 접근하는 경우에만 반응성을 추적하도록 설계되어 있기 때문에 .value.value 와 같은 .value 내부의 value 까지는 추적할 수 없다.

#### 해결 방안
- 위와 같은 문제를 파악하고, .value 를 중첩해 단계를 두 번으로 나눠 변경을 추적하는 방법을 적용하려 했으나, 아래와 같은 추가 문제로 인해 그렇게 사용할 수 없게 됨

#### 추가 문제
- SelectBox Type 타입의 구조와 변경 방식 문제
	- 변경을 추적하고자 하는 변수를 최초 선언할 때, ref\<SelectBox>(\~~) 와 같이 ref 내부에 SelectBox 객체를 가지고 있는 방식으로 선언
	- q-select의 v-model 에 해당 변수가 바인딩 되어 있고, q-select 에서 값을 선택하면, 해당 변수 객체 자체가 변경된다.
	- 이는 객체의 속성 값만 변경되는 것이 아니라, 객체 자체가 새로운 객체로 교체되는 것을 의미한다.
	- q-select 를 통해 변수 값을 바꾸면, 변수.value 가 변경되는 것이 맞지만, 변경되는 과정이 SelectBox 타입의 객체가 교체되는 것이다.
	- computed 속성은 객체의 변경은 감지하지 못한다. .value의 변경 여부만 파악할 뿐, 객체 자체의 교체 여부는 파악할 수 없다는 의미이다.
- 변경 감지를 원하는 변수는 SelectBox 객체인데, 이 객체의 내용만 바뀌는게 아니라, q-select 에서 새로운 항목을 선택할 때마다, 객체 자체가 완전히 새로운 객체로 교체된다. Vue 의 반응형 시스템은 객체 자체의 참조가 변경되는 경우까지는 기본적으로 감지하지 못하기 때문에 위 방법도 변경을 감지할 수 없다.

#### 최종 해결 방법
- watch 로 select 객체 변경 감지