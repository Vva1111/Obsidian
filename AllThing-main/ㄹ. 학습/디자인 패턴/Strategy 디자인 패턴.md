- 알고리즘 군을 정의하고, 각각을 캡슐화하여 런타임에 알고리즘을 교체할 수 있도록 하는 패턴
- 어떤 기능을 수행하는 방법(전략)을 객체로 분리해서 상황에 따라 전략을 바꿀 수 있게 하는 구조
- '전략' 이란, 일종의 알고리즘 혹은 기능. 동작이 될 수도 있는 특정한 목표를 수행하기 위한 행동 계획을 모두 포함하는 개념
- 어떤 일을 수행하는 알고리즘이 여러가지 일 때, 동작들을 미리 전략으로 손쉽게 교체할 수 있는, 알고리즘 변형이 빈번하게 필요한 경우에 적합한 패턴


### 구조
![[Pasted image 20251105110254.png]]
1. **전략 알고리즘 객체들** : 알고리즘, 행위 동작을 객체로 정의한 구현체
2. **전략 인터페이스** : 모든 전략 구현체에 대한 공용 인터페이스
3. **컨텍스트** : 알고리즘을 실행해야 할 때 마다 해당 알고리즘과 연결된 전략 객체의 메소드를 호출한다.
4. **클라이언트** : 특정 전략 객체를 컨텍스트에 전달함으로써 전략을 등록하거나 전략 알고리즘을 실행한 결과를 얻는다.
* 프로그래밍에서의 컨텍스트는 콘텐츠를 담는 곳을 뜻하며, 어떤 객체를 핸들링 하기 위한 접근 수단이다.

### 정의
1. 동일 계열의 알고리즘 군을 정의하고 -> 전략 구현체로 정의
2. 각각의 알고리즘을 캡슐화 -> 인터페이스로 추상화
3. 이들을 상호 교환이 가능하도록 만든다 -> 합성(composition)으로 구성
4. 알고리즘을 사용하는 클라이언트와 상관 없이 독립적으로 -> 컨텍스트 객체 수정 없이
5. 알고리즘을 다양하게 변경할 수 있게 한다. -> 메소드를 통해 전략 객체를 실시간으로 변경함으로써 전략을 변경

### 사용 시기
- 전략 알고리즘의 여러 버전 또는 변형이 필요할 때 클래스화를 통해 관리
- 알고리즘 코드가 노출되어서는 안 되는 데이터에 엑세스 하거나 데이터를 활용할 때 ( 캡슐화 )
- 알고리즘의 동작이 런타임에 실시간으로 교체되어야 할 때

### 장점
- 알고리즘을 캡슐화해 교체 가능 ( OCP, 개방-폐쇄 원칙 준수 )
- 코드 중복 제거, 테스트 용이
- if/else 분기문 제거 -> 가독성 향상

### 주의점
- 알고리즘이 많아질수록 관리해야 할 객체의 수가 늘어나는 단점
- 어플리케이션의 특성이 알고리즘이 많지 않고 자주 변경되지 않는다면, 새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다.
- 적절한 전략을 선택하기 위해 전략 간의 차이점을 파악하고 있어야 한다. ( 복잡도 상승 )

### 실무 사용 예시
- **i18n**
	- 모든 언어 번역 전략(TranslationStrategy) 은 translate(key: string): string 을 가져야 한다.
	- 국가 언어 별로 번역(전략) 테이블을 가지고 있음. 각 클래스는 같은 key에 대해 각기 다른 언어 문자열을 반환한다.
	- TranslationContext 가 현재 언어 상태를 기억하고, 그에 맞는 전략 객체를 내부에 보관한다.
		- 사용자가 언어를 바꾸면, setLanguage() 와 같은 메서드가 호출되어 TranslationStrategy 가 이전 언어 전략에서 변경하려는 언어 전략으로 변경된다.
		- UI에서 translate('message') 를 호출하면 Context는 현재 전략에게 위임한다.
		- context.translate("welcome_message")
		- → EnStrategy.translate("welcome_message")
		- → "Welcome!"
- **날짜 포맷 변경**
- **통화 포맷 변경**
- **단위 변경**
- **테마 변경**
