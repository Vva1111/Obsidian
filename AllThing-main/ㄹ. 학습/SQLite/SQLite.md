[SQLite Internals: How The World's Most Used Database Works](https://www.compileralchemy.com/books/sqlite-internals/)

---

# 목차

### SQLite의 특징, 장점

### Overview

1. SQLite의 대략적인 구조
2. 내부 구조 별 기능 및 특성
3. SQLite의 전체적인 작동 방식
4. 중요한 개념들

### File & Record Format

### SQLite 외의 임베디드 데이터베이스

### 추가 개념

/

---

## 특징

- 서버 없이 사용하는 DB 엔진 : SQLite의 제작자인 Richard Hipp은 미 해군 구축함에 들어가는 소프트웨어 개발자였다. 함선의 특성 상 서버가 불안정하거나 전투 중에 피해를 입어도 제대로 작동이 가능한 DB엔진이 필요했지만 맘에 드는 것을 찾아내지 못했고, 직접 만드는 것으로 결정했다.
    
- B-Tree 구조를 사용한다.
    
- 완벽히 호환되는 형상 관리 시스템 : Git을 사용하고 있었으나, 몇몇 기능들이 충족되지 않았고, 이는 그가 스스로 Version Control System인 Fossil 을 만들게 되는 계기가 됐다.
    
- 사용자 정의 파일에 저장 : 만약 파일에 데이터를 저장하고 싶다면, 그냥 SQLite DB를 공유, 사용하면 된다.
    
- SQLite는 최고의 DB 레퍼런스 플랫폼으로써 postgres가 채택하는 SQL 표준을 따라잡기 위해 노력한다.
    
- Flexible Typing : SQLite 는 정적 자료형 시스템은 가지는 다른 DB 시스템과는 달리 동적 자료형 시스템을 선호한다.
    
    - 칼럼에 대한 데이터 자료형은 필수가 아닌 권장이며, 이는 ‘열 선호도’를 나타낼 뿐이다.
    - SQLite로 생성한 데이터 테이블의 칼럼에 저장된 값들은 특정 자료형에 제한되지 않는다.
    - 칼럼에 선언한 자료형과는 다른 자료를 입력하더라도 SQLite는 이를 문제 없이 받아들인다.
    - SQLite는 `NULL`, `INTEGER` ( 1, 2, 3, 4, 8 Bytes의 정수 ), `REAL`( 8Bytes의 부동 소수점 값 ), `TEXT`, `BLOB`( 입력 그대로 저장된다. 바이너리, 이미지, 비디오, MP3와 같은 대형 멀티미디어 파일을 직접 저장하는 용도로 사용, BLOB의 최대 크기는 이론적으로는 제한이 없다. ) 의 다섯 가지 기본 자료형을 제공한다.
    
    ⇒ 이는, 여러 자료가 필요한 단일 애플리케이션을 위한 단일 테이블을 만드는 일을 편리하게 만들며, 테이블을 개념적으로 더 단순하고, 효율적으로 만들어 접근, 수정을 용이하게 한다.
    
    또한, 동적 프로그래밍 언어를 사용하면 변수가 어떤 데이터 유형을 보유할지 미리 예측할 수 없기 때문에 해당 값을 저장해야 하는 경우 유연한 입력을 지원하는 데이터베이스가 있으면 저장이 훨씬 쉬워진다는 이점이 있다.
    
    ⇒ 반면, 이러한 동적 자료형 시스템은 버그에 취약하거나 데이터의 오염, 다른 데이터베이스 시스템과의 차이점으로 연동이 어렵다는 단점을 들 수 있다.
    
- SQLite의 코드는 Fossil(VCS) 에 의해 관리 되어진다. 그리고 Fossil은 SQLite 를 사용한다.
    
- 프로젝트에 SQLite를 쉽게 삽입하고 컴파일 할 수 있도록 모든 파일이 통합되는 소스 파일을 제공한다.
    
- 임베디드 혹은 Serverless 환경에서 주로 사용하며, 동일 데이터를 파일로 처리하는 것보다 30% 이상 좋은 성능을 보여준다. ( [https://memories.tistory.com/85](https://memories.tistory.com/85) )
    
- 기기 내부에서 파일 형태( .db ) 로 저장된다. ( [https://onepinetwopine.tistory.com/271](https://onepinetwopine.tistory.com/271) )
    
- 일반 SQL문을 동일하게 사용 가능하다
    
- 윈도우, MacOS, 리눅스, IOS, 안드로이드를 비롯한 다양한 플랫폼에 이식됐고, 어디서나 사용 가능 하다.
    
- 배포를 위한 특별한 방법이 필요 없으며, 애플리케이션과 동일한 디렉토리에 넣기만 하면 된다.
    
- 많은 언어에서 SQLite를 위한 고수준 바인딩이 라이브러리로 존재한다.
    
- SQLite는 설계 원칙 상 적합하지 않은 프로젝트가 뚜렷하다.
    
    ( [https://www.itworld.co.kr/news/117213](https://www.itworld.co.kr/news/117213) )
    
    1. SQLite가 지원하지 않는 기능을 사용하는 앱 : SQLite는 여러 가지 관계형 DB 기능을 지원하지 않으며, 앞으로도 지원 할 계획이 없다.
    2. 수평 확장 설계가 필요한 앱 : SQLite 인스턴스는 단일체이며, 독립적이고, 인스턴스 간 기본 동기화 기능이 없다. 또한, 여러 개를 연합하거나 클러스터를 만들 수 없다.
    3. 여러 연결에서의 동시 쓰기 작업을 실행하는 앱 : SQLite는 쓰기 작업 시 DB를 잠그므로, 여러 동시 쓰기 작업이 실행되는 앱에서는 성능 문제가 발생할 수 있다. 다만, 동시 읽기 작업을 실행하는 앱은 대체로 빠르게 실행된다.
    4. 강한 데이터 형식 지정이 필요한 앱 : SQLite의 데이터 형식은 비교적 소수다.

## 장점

- *트랜잭션과 *원자성 동작을 지원하므로 프로그램 충돌이나 정전이 발생하더라도 데이터베이스가 손상되지 않는다.
    
- 전체 텍스트 인덱싱, JSON 데이터 지원 등 고급 데이터베이스에서 볼 수 있는 여러 기능이 있으며, 일반적으로 YAML, XML과 같이 반 구조적인 형식으로 저장되는 애플리케이션 데이터는 SQLite 테이블로 저장할 수 있으므로 데이터에 더 쉽게 접근/처리 할 수 있다.
    
- 프로그램의 구성 데이터를 저장하는 빠르고 강력한 수단도 제공한다. YAML과 같은 파일 형식을 파싱하는 대신 SQLite를 이러한 파일의 인터페이스로써 사용할 수 있다.
    
- 단일 독립형 바이너리 이므로 앱과 함께 배포하고, 필요에 따라 앱과 함께 이동하기가 쉽다
    
- 수 많은 서드파티 프로젝트가 SQLite를 위한 부가적인 도구를 제공한다.
    
    ( [https://www.itworld.co.kr/news/117213](https://www.itworld.co.kr/news/117213) )
    

<aside> 💡 트랜잭션 : DB의 상태를 변화시키기 위한 작업 수행의 논리적 단위를 뜻하며, 작업 단위는 사용자가 특정 기능의 수행을 위해 SQL작업을 묶은 단위를 말한다. 예를 들어, 비즈니스 로직 내부에서 오류나 충돌이 발생 해 롤백이 일어났을 경우, 작업 사이에 데이터 불일치가 일어날 가능성이 있다. 이를 방지하기 위해 연관된 과정을 하나의 트랜잭션으로 묶어야 데이터의 일관성을 유지할 수 있다.

</aside>

<aside> 💡 원자성 : 하나의 트랜잭션이 더 이상 작게 쪼갤 수 없는 최소한의 업무 단위. 트랜잭션 내부에서 실행된 작업들은 모두 성공해서 Commit 되거나, 문제가 생겼을 경우 트랜잭션 통째로 롤백되어야 한다. 즉, 작업의 일부만 성공하거나 실패할 수 없다는 뜻이다.

</aside>

## Overview

---

1. SQLite의 대략적인 구조
![[Untitled.png]]

( YACC/Bison의 파서가 토크나이저를 호출하는 방식과는 다르게 토크나이저가 파서를 호출하는 방식도 가능하도록 설계되어 있다. )

( SQL 문을 포함하는 스트링이 실행될 때, 인터페이스는 스트링을 토크나이저로 전송한다. 이 토크나이저의 역할은 원래의 스트링을 쪼개어 토큰화하고 하나씩 파서로 전송한다. )

![[Untitled 1.png]]

- 컴파일러는 SQL 코드를 받아 bytecodes 로 구성해 VM으로 전달하고, VM에서 해당 bytecodes를 작동시킨다.

![[Untitled 2.png]]

- SQLite에서 ‘준비된 명령문’, 즉, bytecodes를 처리하는 라이브러리의 첫 번째 부분,
    
    컴파일러(parser, codegenerate)
    

![[Untitled 3.png]]

- 프로그램을 실행하는 라이브러리의 두 번째 부분

![[Untitled 3 1.png]]

- Storage Engine - B-Tree 부터 OS Interface까지 부분

---

1. 내부 구조 별 기능, 특성
    
    1. Tokeniser - Parser
        
        - 제작자인 Dwayne Richard Hipp은 YACC, Bison, Lex 의 사용에 대해 이해하고 있지 못했고, 그래서 그는 lemon 이라는 파서를 스스로 만든다.
            
        - 후입선출 방식의 자동화, *Reentrant, *Thread-safe한 방식을 사용한다.
            
        - AST 형식의 결과물을 산출한다.
            
        - SQLite용 SQL 언어 파서는 ‘Lemon’이라는, 직접 개발한 코드 생성기(code-generator) 프로그램을 사용해 생성된다. ( [https://www.sqlite.org/lemon.html](https://www.sqlite.org/lemon.html) )
            
        - ‘Lemon’은 입력 언어의 문법을 읽고 C코드를 내보내 해당 언어에 대한 파서를 구현한다
            
        - ‘Lemon’에는 자체 소스 저장소가 없으며, SQLite 소스 트리의 몇 가지 파일로 구성된다.
            
        - lemon.html : Lemon에 대한 원래의 자세한 사용법 문서 및 프로그래머 참조 lemon.c : 문법 파일을 읽고 해당 파서 C코드를 생성하는 유틸리티 프로그램의 소스 코드 lempar.c : 생성된 파서 C코드의 템플릿, 'lemon' 유틸리티 프로그램은 이 템플릿을 읽고 파서를 생성하기 위해 추가 코드를 삽입한다.
            
        - Lemon은 *LARL(1) 파서를 생성한다. Yacc / Bison과 유사하지만, 다음의 개선 사항이 추가되었다.
            
            - 문법 구문 오류 발생 가능성이 적다
            - Lemon에서 토크나이저는 파서를 호출한다. Yacc는 토크나이저를 호출하는 파서와 함께 반대 방향으로 작동한다
            - Lemon 접근 방식은 *Reentrant하고 *Thread-safe한 반면, Yacc는 전역 변수를 사용하므로 둘 다 아니다.
            - Reentrancy한 것은 일부 SQL문이 구문 분석기에 대한 재귀 호출을 수행하기 때문에 SQLite에 특히 중요하다. ( 예를 들어, CREATE TABLE문을 구문 분석할 때, SQLite는 파서를 재귀적으로 호출해 sqlite schema 테이블에 새 항목을 만들기 위해 INSERT문을 생성한다. )
        - Lemon은 SQLite 내부 두 곳에서 사용한다.
            
            1. 주요 용도는, SQL언어 파서를 만드는 일이며,
            2. *FTS5 확장의 쿼리 패턴 표현식에 대한 파서를 생성하는 데 사용된다.
            
            ( *FTS5 : DB 애플리케이션에 전체 텍스트 검색 기능을 제공하는 SQLite 가상 테이블 모듈, 가장 기본적인 형태의 전체 텍스트 검색을 통해 사용자는 하나 이상의 검색어 인스턴스를 포함하는 하위 집합에 대한 대규모 문서 모음을 효율적으로 검색할 수 있다. 사용자가 원하는 검색 결과 중 일부의 단어를 포함하는 모든 문서 검색을 할 수 있도록 한다 - [https://www.sqlite.org/fts5.html#the_fts_index_idx_and_data_tables_](https://www.sqlite.org/fts5.html#the_fts_index_idx_and_data_tables_) )
            
            ![[Untitled 5.png]]
            
            ( SQLite 공식 문서에서 검색어를 통한 검색 시 나타나는 문구 )
            
        - Code-generator 의 도구(Lemon) 를 프로젝트의 일부로 호스팅 하는 장점 중 하나는 전체 프로젝트의 특정 요구 사항을 충족하도록 도구를 최적화 할 수 있다는 점이다.
            
            - 수 년에 걸쳐 Lemon 파서 생성기는 SQLite에 새로운 기능과 향상된 성능을 제공하기 위해 확장/향상 되었다.
            
            → 'fallback token' : Lemon이 일부 키워드를 식별자로 대체할 수 있게 지정해 SQLite 내부의 수 많은 키워드와 식별자 이름이 충돌할 가능성을 줄인다.
            
            → 100% MC/DC 테스트 목표를 지원하기 위해 Lemon에서 생성된 파서코드에는 연결할 수 없는 분기가 없으며, 테스트 범위를 측정하는데 유용한 추가 도구(컴파일 시간 선택) 도구가 포함되어 있다.
            
        - SQL 구문 분석은 모든 SQL 데이터베이스 엔진에서 CPU Cycle의 중요한 소비자이기 때문에 SQLite를 최적화 하기 위한 더 빠른 파서를 생성하는 Lemon을 조정하는 일에 많은 시간을 할애했다.
            
        - SQL 구문 분석은 모든 SQL 데이터베이스 엔진에서 CPU cycle의 중요한 소비자이다. SQLite를 최적화 하기 위한 더 빠른 파서를 생성하는 Lemon을 조정하는데 많은 시간을 할애한다.
            
        
        <aside> 💡 * LALR(Look-Ahead LR) Parser : LALR은 구문 분석 방식의 한 종류이며, 선행 예측(Lookahead) LR 방식의 특별한 버전이다. 단순 LR (Simple LR) 방식의 구문 분석기보다 더 많은 문맥 문법을 다룰 수 있다. 구문 분석을 위한 테이블이 간단해 많은 구문 문법을 처리할 수 있다. YACC/BISON과 같은 컴파일러 소프트웨어가 이러한 방식을 사용해 처리한다. LALR은 단순 LR방식과 동일하게 LR(0)의 구문 분석 테이블을 사용한다. Lemon은 YACC/BISON과 동일한 역할을 담당하며, Lemon이 제공하는 파서는 재 진입 및 스레드 안정성이 보장되지만, Lemon과 YACC/BISON이 호환되지는 않는다. Lemon은 특정 언어에 대한 CFG(Context-Free Grammar)를 C 코드로 변경하는 역할을 담당한다.
        
        </aside>
        
        <aside> 💡 * Thread-safe : 다중 쓰레드 안정성
        
        - Reentrant : 재 진입성 -> 어떤 루틴 또는 프로그램이 'Thread-safe 하다' 라고 한다면, 여러 쓰레드에 의해 코드가 실행된다고 하더라도 실행 결과의 correctness가 보장된다는 것을 뜻한다. 즉, 여러 쓰레드에 의해 진짜로 동시에 수행되거나, 혹은 그렇게 보이더라도 실행 결과 값의 동일성이 보장된다면 'Threa-safe 하다' 라고 말할 수 있다는 것이다. 또한, 위의 상황에서 공유되는 자원이 있다 하더라도, 이것을 여러 쓰레드가 동시에 접근하지 못하도록 막아주기만 하면 된다는 것이다.
        
        -> 이에 반해, 어떤 루틴 또는 프로그램이 'Reentrant 하다' 는 것은 '여러 쓰레드에 의해 쓰레드가 동시 수행되며, 동시에 정확성을 보장한다는 것이다. 'Reentrant 한 코드'는 Thread 사이 공유하는 자원이 없어야만 하는 코드이다. Thread 사이 동기화 메커니즘 자체가 필요 없게 만드는 코드이다. 따라서, Multi Threading 환경에서 여러 Thread가 해당 코드를 동시에 실행하더라도 문제가 없어 보이기만 하면 되는 것이 아니라, 아무런 문제가 없다.
        
        결국, Thread-safe 한 코드는 Multi-Threading 환경에서 Reentrant 한 코드보다 효율이 떨어질 가능성이 높다. 해당 코드를 수행하고 있는 Thread가 공유 자원에 대한 lock이 풀리기를 기다리는 동안 다른 THread의 수행을 막기 때문이다.
        
        </aside>
        
        <aside> 💡 추가) 여러 Thread가 같은 함수를 동시에 실행하는 경우, 가장 큰 문제는 함수가 이용하는 Thread간 공유 자원이다. 공유 자원을 lock같은 동기화 기법으로 보호해 공유 자원의 무결성을 보장해야 한다. 이렇게 공유 자원의 무결성을 보장하는 함수를 Thread-safe 함수라고 한다.
        
        > Reentrant : Thread-safe 함수와 마찬가지로 여러 thread에서 동시에 실행이 가능하지만 thread간 공유 자원을 이용하지 않는 함수를 의미한다. 공유 변수를 이용하지 않기 때문에 각 threead는 언제나 같은 호출 결과를 얻을 수 있다. 이러한 성질을 ‘Reentrant(재 진입 가능) 하다’ 고 표현한다 Reentrant 함수는 Thread-safe 함수이지만, Thread-safe 함수는 Reentrant 함수라고 말할 수 없다.
        
        </aside>
        
    
    b. Code generator
    
    - 의미론적(semantic) 분석 수행, select.c를 사용해 _AST 변환을 수행한다. where_.c, whereint.h 를 사용해 조인 순서를 결정, select.c 를 사용해 쿼리 사용 계획을 결정 build.c, delete.c, expr.c, insert.c, update.c 를 사용해 바이트 코드 출력 가장 많은 코드 라인이 있는 구역
        
    - AST ( Abstract Syntax Tree - 추상 구문 트리 ) : 프로그래밍 언어로 작성 된 소스코드의 추상 구문 구조의 트리이다. ( [https://yceffort.kr/2021/05/ast-for-javascript](https://yceffort.kr/2021/05/ast-for-javascript) )
        
        - 프로그래밍 언어로 쓰여진 소스 코드의 Abstract Syntax 구조를 표현하기 위해서 사용한다. 다시 말해, 특정 프로그래밍 언어로 작성 된 프로그램 소스 코드를 각각 의미 별로 분리해 컴퓨터가 이해할 수 있는 구조로 변경 시킨 트리를 의미한다.
            
            → Abstract Syntax 란 프로그래밍 언어의 문법 및 각 문단의 역할을 표현하기 위한 규칙인데, data의 구조와 종류만 포함된다.
            
            → data의 구조와 종류라는 것은, 예를 들어 C 에서의 while이 의미하는 바는, 'condition', 'statement'이며, int a에서 'a'가 의미하는 것은 변수명을 나타내는 'identifier' 이다.
            
            → 즉, Abstract Syntax는 'statement', 'expression', 'identifier' 등과 같이 나눌 수 있도록 정의하는 문법 표현을 위한 규칙이다.
            
        - AST는 abstract하게 짜여진 parsing tree이므로, 컴파일 단계에서 더 추가적으로 데이터나 정보들이 붙을 수 있다.
            
        - AST는 컴파일러가 프로그램의 각 부분의 사용이 옳바른지, 프로그래밍 언어의 사용에 틀린 부분은 없는지, Sementic Analysis ( 문맥적인 소스코드 검사 )의 단계에서 사용되곤 한다. AST의 모든 단계를 거쳤을 때 이상이 없다는 것은 프로그램이 정확하다는 의미를 가진다.
            
	        ( 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다. )
	        
	        ( 구문이 추상적이라는 의미는 실제 구문에서 나타나는 모든 세세한 정보를 나타내지는 않는다는 의미이다. 예를 들어, 그룹핑을 위한 괄호는 암시적으로 트리 구조를 가지며, 분리된 노드로 표현되지는 않는다. )
	        
	    - 💡 JavaScript 에서의 AST 예 ( [https://yceffort.kr/2021/05/ast-for-javascript](https://yceffort.kr/2021/05/ast-for-javascript) )
		    ![[Untitled 6.png]]
		    위의 간단한 코드를 AST로 변환하면
			![[Untitled 7 2.png]]
	        …
	        ![[Untitled 7 1.png]]
	        …
	        ![[Untitled 7 2.png]]
	        와 같은 형태로 표현된다.
	        - 코드 텍스트에서 트리 구조의 데이터 스트럭쳐를 만들어 낸다.
	        - 코드에 있는 아이템이 각 트리에 있는 노드와 매치된다.
	        - 이러한 작업은 컴파일러가 하는데, 여기서는 고수준 → 바이트 컴퓨터 처리가 아닌, 렉시컬 / 구문 분석에만 중점을 둔다.
	        - 컴파일 과정
			        - 렉시컬 분석(Scanner) : 텍스트의 어휘 패턴을 인식하는 프로그램. 코드의 문자들을 읽어서 정해진 룰에 따라 이들을 토큰으로 만들어 합친 후에 공백, 주석 등을 지우고 전체 코드를 글자 단위로 나눈다. 렉시컬 분석기가 소스 코드를 읽을 때, 코드를 글자 단위로 읽는다. 그 과정에서 공백, operator symbol, special symbol을 만나면 해당 단어가 끝난 것으로 간주한다.
				        ( ※ Lex : 스캐너를 만들 수 있는 툴, Lex에서는 정규식을 사용하며, Lex가 파일이나 텍스트 형식으로 입력을 받으면, Lex는 텍스트를 정규식과 대조시킨다. Lex는 한번에 한 문자씩 받아서 패턴이 일치 될 때까지 계속 반복한다. 패턴이 일치되면 Lex는 관련된 작동(토큰의 반환 등) 을 실행한다. 이와 반대로 일치되는 정규식이 없으면 Lex는 더 이상의 처리를 중단하고 오류 메세지를 출력한다. Lex는 C와 밀접한 관련이 있는데, 확장자가 ‘.lex’ 인 파일이 Lex 유틸리티를 통과하면 C에 출력 파일이 생성된다. - [https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52960](https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52960) )
				    - 구문 분석(Syntax Parser) : 위에서 나온 결과로 토큰 목록 트리 구조를 만들며, 구조적 혹은 언어적 문제가 있을 경우 에러를 나타낸다. 
					    트리를 만드는 과정에서, 일부 파서들은 불필요한 토큰( 중복된 괄호 등 )을 생략한다.
					    그리고 그 결과로 ‘Astract Syntax Tree’를 만들게 된다.
					    이는 실제 코드와 100% 일치하지는 않지만 코드를 다루기에는 충분하다.
            - 실제 사용 예
	              → 트랜스 파일링 : 자바스크립트의 컴파일러, 바벨은 Parsing, Transforming, Generating의 3단계로 이뤄져 있으며, 바벨에 자바스크립트 코드를 넘기면 AST를 활용해 새롭게 코드를 변환한다.
	              → 코드 자동 리팩토링
	              → Prettier : 자동 줄바꿈, 공백 제거 등 코드 컨벤션 적용. Prettier는 기존의 코드를 받아서 AST로 변환 후, AST를 ‘Intermediate representation’ 혹은 ‘Doc’ 형태로 변환한다.
		              이 때, AST 노드는 포맷팅의 관점에서 어떻게 서로 연관되어 있는지의 정보도 추가되어 변환된다.
		              만약 리스트가 길고, 한 줄에 맞지 않으면 파라미터를 별도의 줄로 분할한다.
		              그 다음, ‘Printer’ 라고 하는 알고리즘이 IR을 거쳐 전체 그림을 바탕으로 코드를 포맷팅 할 방법을 결정하게 된다.
			       → 그 외, JS 의존성 트랜스 파일링, 코드 최소화, CSS pre-processor, eslint 등의 개발 툴들은 AST processing을 기반으로 작동한다.
        
2. Virtual Machine
    
    - 두 번째로 코드 라인이 많은 구역, vdbe.c, vdbe.h, vdbeLnt.h, vdbe*.c, func.c, date.c 의 관련 파일 전 단계로부터 바이트 코드를 실행하는 구조이다.
    - 가상 머신은 SQLite의 프론트 엔드 부분( SQL 구문 분석 및 가상 머신 코드 생성 )과 백 엔드 부분( 가상 머신 코드를 실행 및 결과를 계산 ) 사이에서 확실하고 장 정의된 연결점을 제공한다.
    - 가상 머신은 개발자들이 SQLite가 컴파일하는 각 문법으로 무엇을 하려고 하는지 명확하고 쉽게 읽을 수 있는 형태로 볼 수 있게 해주므로 디버깅에 큰 도움이 된다.
3. B-Tree
    
    - 큰 블록의 데이터를 읽거나 쓰는 경우에 최적화 되어 있기 때문에 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
        
    - SQLite 데이터베이스는 B-Tree를 사용해 디스크를 관리한다. 각 테이블과 인덱스를 위해 별도의 B-Tree가 사용되고, 모든 B-Tree들은 동일한 디스크 파일에 저장된다.
        
    - B-Tree는 순차적인 액세스를 가지고 데이터의 검색, 삽입, 삭제, 정렬을 수행하는 트리 형태의 데이터 구조이다.
        
    - 이진 트리와는 다르게 하나의 노드에 많은 정보를 가질 수 있다.
        
        → 하나의 노드에 여러 정보를 담게 되며 '차수' 라는 개념이 등장한다.
        
        → 하나의 노드에 담은 자료의 수가 M개라면, M차 B-Tree라고 부르며, 자식 노드가 최대 M개 임을 뜻한다.
        
        → 하나의 노드에 여러 정보를 배치하며 이진 트리보다 훨씬 많은 데이터를 더 효율적으로 저장소에 담을 수 있게 되었다.
        
    - B-Tree는 자료를 정렬된 상태로 보관하고, 삽입 및 삭제를 대수 시간으로 할 수 있다. 일반적으로 이진 트리는 항목이 삽입될 때 하향식으로 구성되는데 반해, B-Tree는 일반적으로 상향식으로 구성된다.
        
    - B-Tree의 기본 개념은 내부 노드의 자식 노드의 수가 미리 정해진 범위 내에서 변경 가능하다는 것이다. 항목이 삽입 / 삭제 될 때, 내부 노드는 해당 범위의 자식 노드의 수를 만족 시키기 위해 분리되거나 다른 노드와 합쳐지게 된다. 자식 노드의 수가 일정 범위 내에서만 유지되면 되므로 분리 및 합침을 통한 재 균형 과정은 다른 자가 균형 이진 탐색 트리 만큼 자주 일어나진 않지만 저장 공간에서의 손실은 있게 된다.
        
    - B-Tree는 노드가 모두 채워지지 않는 경우도 발생하므로, 공간을 낭비할 가능성이 있다. B-Tree에서 내부 노드는 미리 정의 된 범위 내의 가변적인 자식 노드를 가질 수 있고, 데이터가 노드에 추가/삭제될 때 자식 노드의 수는 변하게 된다. B-Tree는 내부 노드에 키를 저장하지만, 레코드에는 키를 저장하지 않기 때문에 이러한 특징을 변형해 *B+Tree와 _B_Tree가 나오게 되었다.
        
    - 자식 노드의 최소 및 최대 수는 일반적으로 특별한 구현에 대해서 결정되어 있다. ( 예를 들어, 2-3 B-Tree(혹은 단순히 2-3 트리) 에서 각 내부 노드는 2 또는 3개의 자식 노드를 가질 수 있다. 만약, 허용되지 않은 수의 자식 노드를 가질 경우, 해당 내부 노드는 부적절한 상태에 있다고 판단한다. )
        
    - B-Tree는 노드 접근 시간이 노드에서의 연산 시간에 비해 훨씬 길 경우, 다른 구현 방식에 비해 상당한 이점을 가지고 있다. 이는 대부분의 노드가 하드디스크와 같은 2차 저장장치에 있을 때 일반적으로 일어난다
        
    - 각 내부 노드에 있는 자식 노드의 수를 최대화 함으로써 트리의 높이는 감소하고, 균형 맞춤은 덜 일어나며, 효율은 증가하게 된다. 대개 이 값은 각 노드가 완전한 하나의 디스크 블록 혹은 2자 저장 장치에서 유사한 크기를 차지하도록 정해진다.
        
    - B-Tree의 B는 대개 Balanced로 알려져 있다. ( 리프 노드를 같은 높이에서 유지 시켜주기 때문에 균형 잡혀 있다는 뜻의 balanced )
        
    - HDD, SDD와 같은 외부기억장치는 블럭단위로 파일을 입출력한다. 이 때 발생하는 입출력 비용은 파일의 크기와는 상관 없이 동일하다. 예를 들어, 1KB 블럭에 1byte짜리 알파벳 하나가 들어가 있어도 1KB 블럭이 모두 차 있는 것과 동일한 상황이라는 것이다.
        
        → 이러한 비효율을 없애기 위해 하나의 블럭에 여러 데이터를 동시에 저장해 블럭을 효율적으로 사용하기 위해 B-Tree를 사용한다.
        
        → 또한, 균형 이진 트리의 연속이기 때문에 균형적으로 트리의 높이를 유지시켜 최악의 경우에도 O(logN)의 검색 성능을 보인다.
        
    
    <aside> 💡 B-Tree의 특징
    
    - 각 노드의 자료는 정렬되어 있다.
    - 자료는 중복되지 않는다.
    - 모든 leaf node는 같은 레벨에 있다.
    - root node는 적어도 2개 이상의 자식을 가진다.
    - leaf node는 적어도 M/2 개의 자식 노드를 가진다. ( 최대 M개 )
    - 대수 연산 시간을 제공하는 데이터 구조이다.
    - 데이터베이스 파일 별로 B-Tree가 여러 개 있을 수 있다.
    - 선택자를 사용해서 읽으며, 동일한 테이블에 대한 동시 읽기 및 쓰기는 서로 다른 커서를 사용해 수행된다. </aside>
    
    <aside> 💡 이진 트리 : 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조 정 이진 트리 : 트리의 모든 노드가 0 혹은 2개의 자식을 가지는 트리 포화 이진 트리 : leaf node가 끝까지 꽉 찬 트리 완전 이진 트리 : 마지막 레벨을 제외한 모든 레벨에서 순서대로 노드가 꽉 채워진 트리 균형 이진 트리 : leaf node들의 레벨 차이가 최대 1 레벨 까지만 나는 트리 ( 균형이 깨지면 별도의 로직을 통해 다시 균형 유지 ) ( 위의 세 트리의 경우, 이상적인 자료 구조이기 때문에 현실적으로 잘 나타나지 않지만, 균형 이진 트리 같은 경우 한 쪽으로 쏠릴 수 있는 현실 상황에서도 균형적으로 트리의 높이를 유지 시킬 수 있기 때문에 많이 사용한다.) ( 균형 이진 트리의 경우, 최악의 경우에도 O(logN) 복잡성을 가질 수 있다. ) ( 균형 이진 트리의 경우, B-Tree, B+Tree, B*Tree 에서 주로 사용한다. )
    
    </aside>
    
    <aside> 💡 B**Tree : B-Tree의 단점 중 하나인 구조를 유지하기 위해 연산을 추가하거나 새로운 노드가 생성되는 것을 최소화 하기 위해 몇 가지 규칙을 추가.
    
    B-Tree와 B**Tree의 가장 대표적인 차이점은 기존 노드의 자식 노드 수 최소 제약 조건이 2M/3개로 늘어났고, 노드가 가득 차면 분열 대신 이웃한 형제 노드로 재배치 된다는 점이다. ( 더 이상 재배치 할 수 없는 시점에서 분열 ) leaf node들은 적어도 2[(M-2)/3] + 1 개의 자식 노드를 가진다는 차이점 외에는 다른 특징은 B-Tree와 동일하다.
    
    </aside>
    
    <aside> 💡 B+Tree : 탐색을 위해 노드를 찾아 이동 해야하는 단점을 가진 B-Tree를 보완하기 위해 같은 레벨의 모든 키 값이 정렬되어 있으며, 같은 레벨의 Sibiling node는 연결 리스트로 이어진 특징을 가진다. ( 같은 레벨의 Sibiling node는 모두 연결되어 있어 키 값이 중복되지 않는다. ) 만약, 특정 값을 찾아야 하는 상황이 된다면, leaf node에 모든 자료들이 존재하고, 그 자료들이 연결 리스트로 연결되어 있으므로, 탐색에 있어서 매우 유리하다. B+Tree의 특징 데이터 노드의 자료는 정렬되어 있다. 데이터 노드에서는 데이터가 중복되지 않는다. 모든 leaf node는 같은 레벨이 있다. leaf node가 아닌 node의 키 값의 수는 그 노드의 서브 트리 수 보다 하나가 적다. 모든 leaf node는 연결 리스트로 연결되어 있다.
    
    </aside>
    
4. Pager
    
    - 페이지 캐시 라고도 불린다. 정전 시 데이터 손상을 방지한다. 이를 위해 상호 독립적인 두가지 모드를 사용한다. Roll back 모드 또는 Write Ahead Log(WAL) 모드 또한 이것은 동시 제어를 강제한다. 메모리 내 캐시 처리 담당 관련 파일 : pager.c, pager.h, pcache1.c, pcache.c, pcache.c, pcache.h, wal.c
5. Shim ( [](https://en.wikipedia.org/wiki/Shim_(computing))[https://en.wikipedia.org/wiki/Shim_(computing)](https://en.wikipedia.org/wiki/Shim_(computing)) )
    ![[Untitled 10.png]]

- 압축, 로깅 및 암호화 담당, OS 계층을 에뮬레이션 하는데 사용한다. 하드웨어 오류를 시뮬레이션 하는 테스크에 사용된다.
- 컴퓨터 프로그래밍에서 shim은 API 호출을 투명하게 가로채고, 전달 된 인수를 변경하고, 작업 자체를 처리하거나 작업을 다른 곳으로 리디렉션 하는 라이브러리이다.
- shim은 중개자 역할을 하고, 프로그램의 동작이나 작동을 부분적으로 또는 완전히 변경하는 코드 라이브러리에 대한 일반적인 용어이다.
- shim은 최신 환경에서 이전 API를 지원하거나 이전 환경에서 새 API를 지원하는 데 사용할 수 있다.
- 개발 대상이 아닌 다른 소프트웨어 플랫폼에서 프로그램을 실행하는 데에도 사용할 수 있다.
- 이전 API에 대한 shim은 일반적으로 API의 동작이 변경될 때 발생하므로 여전히 이전 기능에 의존하는 이전 애플리케이션에 대한 호환성 문제를 일으킨다. 이러한 경우, 최신 코드 위에 있는 얇은 호환성 계층에서 이전 API를 계속 지원할 수 있다.
- 최신 API용 shim은 '해당 환경의 수단만 사용해 이전 환경에 새 API를 제공하는 라이브러리'로 정의된다.
- API의 일부가 아닌, API 수준에서 기능을 제공하는 일종의 어댑터이다. ( [https://stackoverflow.com/questions/2116142/what-is-a-shim](https://stackoverflow.com/questions/2116142/what-is-a-shim) - stackoverflow )
- 관련 파일 : test_multiplex.c, test_vfstrace.c

<aside> 💡 소프트웨어 shim은 기계 엔지니어링 shim과 동일한 목적을 수행한다. 즉, 설계가 완전히 일치하지 않는 두 가지가 함께 작동할 수 있게 해준다. 예를 들어, 기계 엔지니어링 Shim의 경우, 자전거의 안장 기둥이나 프레임 튜브의 너비가 정확하게 일치하지 않는 경우 이를 해결하기 위한 방안으로 외부 튜브와 내부 실린더 사이의 틈을 채우는 용도의 얇은 금속판인 심을 사용할 수 있다. 소프트웨어의 예를 들자면, Gnome 창 관리자는 모든 UNIX에 설치할 수 있었지만, 3.14버전부터 Gnome은 UNIX 관련 구성 요소인 systemd에 종속되었다. 이럴 경우, 일반적으로 Gnome이 다른 UNIX 변형(FreeBSD 등)이나 systemd를 포함하지 않는 LINUX 배포판에서 유용하지 않게 된다. 이 문제를 해결하기 위해 systemd api를 제공하고 이를 기본 OS에 대한 호출로 변환하는 라이브러리를 작성했다. 이러한 라이브러리는 호환되지 않는 인터페이스가 있는 두 개의 큰 시스템이 함께 작동되도록 하는 얇은 레이어에 불과하기 때문에 'shim'이라는 이름에 매우 적합하다.

- shim은 일반적으로 입력을 받아 무언가를 수행한 후, 기능적인 다른 레벨(수준)에 전달하는 작은 소프트웨어(라이브러리) 이다.

( [https://www.quora.com/What-is-a-shim-in-programming](https://www.quora.com/What-is-a-shim-in-programming) )

</aside>

<aside> 💡 CPU Shim은 CPU와 히트싱크 사이에 사용되는 얇은 알루미늄 또는 구리 판이다.

</aside>

- 이와 관련된 개념으로, Pollyfill이 있다.
    
    Polyfill : 최신 기능을 지원하지 않는 이전 브라우저에서 최신 기능을 사용할 수 있게 도와주는 코드 모음. HTML5 혹은 CSS3와 오래된 브라우저 사이의 간격을 메꾸는 역할을 하는 코드 모음이라고 볼 수 있다. → 폴리필은 브라우저가 지원하지 않는 신규 API 구현을 위해 존재 → 폴리필이 독점적으로 사용되지 않는 이유는 더 나은 기능성과 더 나은 성능을 위해서 사용되기 때문이다. API의 기본 구현은 polyfill보다 더 많은 작업을 수행할 수 있고, 더 빠르다. → 폴리필은 브라우저가 다른 방식으로 동일한 기능을 구현하는 ‘문제를 해결하는데’ 사용된다. 특정 브라우저에서 비표준 기능을 사용해 JavaScript 기능에 엑세스 할 수 있는 표준 준수 방법을 제공한다. → 폴리필의 초기 예로는, JQuery 첫 번째 버전(모든 브라우저에서 작동하는 단일 공통 API를 가질 수 있도록 기본적으로 브라우저 별 해결 방법을 편집한 것)이 있다. -> 현재는 표준 시멘틱에 따라 광범위한 API 세트를 구현하기 때문에 폴리필을 통한 브라우저 별 구현 처리는 줄어들었다.
    

1. OS Interface ( Virtual File System - VFS )

- 서로 다른 운영 체제 사이에서도 SQLite를 이식할 수 있도록 하며, SQLite의 다른 모듈이 운영 체제와 통신해야 할 때마다 VFS에서 메서드를 호출한다. 그 다음, VFS는 요청을 충족하는데 필요한 운영 관련 코드를 호출한다.
- SQLite를 새 운영 체제로 porting(응용 프로그램이 개발되었던 원 운영체제 환경과는 다른 타 운영체제 환경에서 실행될 수 있도록 새로운 환경으로 옮기는 일 ) 하는 일은 단순히 새로운 OS 인터페이스 계층(VFS)을 작성하기만 하면 된다.
- 표준 SQLite 소스 트리에는 Unix 및 Windows용 내장 VFS가 포함되어 있다.
- sqlite3_vfs_register() 인터페이스를 사용해 시작 시간 또는 런타임에 대체 VFS를 추가할 수 있다.
- 여러 VFS를 동시(다중 VFS)에 등록할 수 있다. 각 VFS에는 고유한 이름이 있으며, 동일한 프로세스 내에서 별도의 데이터베이스 연결은 동시에 다른 VFS를 사용할 수 있다.
    - 이와 관련해 단일 데이터베이스 연결에 *Attach 명령을 사용하여 열린 여러 데이터베이스 파일이 있는 경우 연결된 각 데이터베이스는 서로 다른 VFS를 사용할 수 있다.)
        
    - ATTATCH DATABASE 문은 현재 데이터베이스 연결에 다른 데이터베이스 파일을 추가한다. 이전에 첨부된 데이터베이스 파일은 DETACH DATABASE 명령을 이용해 제거할 수 있다.
        
    - 표준 Unix VFS : 'unix'라고 하며, 대부분의 응용 프로그램에서 사용된다. → unix-dotfile, unix-excl, unix-none, unix-namedsem 등의 VFS가 있다. → 다양한 유닉스 VFS는 파일 잠금을 처리하는 방식만 다르다. 대부분의 구현을 서로 공통으로 공유하고 모두 동일한 SQLite 소스 파일에 있다.
        
    - 표준 Windows VFS : 기본 Windows VFS는 'win32'라고 하며, 대부분의 응용 프로그램에서 사용된다.
        
        → win32-longpath, win32-none, win32-longpath-none → 유닉스와 마찬가지로 다양한 Windows VFS에 대한 대부분의 코드가 공유된다.
        
    - VFS shim : SQLite 스택의 상위 계층의 관점에서 볼 때, 열려있는 각 데이터베이스 파일은 정확히 하나의 VFS만을 사용한다. 그러나, 실제로 특정 VFS는 실제 작업을 수행하는 다른 VFS를 둘러싼 얇은 래퍼일 수 있다. 이러한 래퍼 VFS를 'shim' 이라고 한다.
        
        ( 간단한 예로, 'vfstrace'가 있는데, 이것은 VFS로 각 VFS메서드 호출과 관련된 메세지를 로그 파일에 기록한 다음 실제 작업을 수행하기 위해 다른 CFS에 제어권을 넘긴다. )
        
    - VFS 구현
        
        → 새로운 VFS는 sqlite3_vfs, sqlite3_io_methods, sqlite3_file 세 가지 객체를 서브클래싱 하여 구현된다. ( sqlite3 : SQLite 라이브러리의 외부와 연결되는 심볼들은 다른 API들과의 충돌을 치하기 위해 sqlite3를 붙인다. )
        
        1. sqlite3_vfs : VFS의 이름과 운영 체제에 대한 인터페이스를 구현하는 핵심 메서드( 파일 존재 확인, 파일 삭제, 파일 생성, 열기 및 읽기/쓰기, 파일 이름을 표준으로 변환 등) 를 정의한다. 운영 체제에서 무작위성을 얻고, 프로세스를 일시 중단 하고 현재 날짜 및 시간을 찾기 위한 메서드도 포함되어 있다.
        2. sqlite3_file : 이 개체는 열린 파일을 나타낸다. sqlite3_vfs의 xOpen 메서드는 파일이 열릴 때 sqlite3_file 개체를 구성한다. sqlite3_file은 파일이 열려있는 동안 파일의 상태를 추적한다.
        3. sqlite3_io_methods : 이 개체는 열린 파일과 상호 작용하는데 사용되는 메서드를 보유한다. 각 sqlite3_file에는 그것이 나타내는 파일에 적합한 sqlite3_io_methods 개체에 대한 포인터가 포함되어 있다. sqlite3_io_methods 개체에는 sqlite3_file 객체 파일 읽기 및 쓰기, 파일 자르기, 영구 저장소에 대한 변경 사항 플러시, 파일 크기 찾기, 파일 잠금 및 잠금 해제, 파일 닫기, 제거와 같은 작업을 수행하는 메서드가 포함되어 있다.

---

1. SQLite의 전체적인 작동 방식( [https://www.sqlite.org/howitworks.html](https://www.sqlite.org/howitworks.html) )

- SQLite는 응용 프로그램에서 생성된 높은 수준의 디스크 I/O 요청을 운영 체제에서 수행할 수 있는 낮은 수준의 I/O 작업으로 변환하는 소프트웨어 라이브러리이다.
    
- SQLite는 각 상위 수준 SQL문을 많은 하위 수준 I/O 요청( 파일 열기, 파일에서 몇 바이트 읽기/쓰기 등 ) 시퀀스로 변환하여 요청한 작업을 SQL을 통해 수행합니다.
    
- 많은 SQL 기반 데이터베이스 시스템이 SQL언어를 사용해 애플리케이션과 통신한다. 하지만, SQLite는 서버리스 소프트웨어이기 때문에 별도의 서버 스레드나 프로세스가 없다. SQLite는 동일한 프로그램 카운터와 힙 저장소를 사용해 응용 프로그램과 동일한 주소 공간에서 실행된다.
    
- SQLite는 IPC( 프로세스 간 통신 )를 수행하지 않는다.
    
- 응용 프로그램이 SQL 문을 SQLite로 보내면 SQLite는 (적절한 SQLite 라이브러리 서브루틴을 호출해) 호출자와 동일한 스레드에서 SQL을 해석한다.
    
- SQLite API루틴이 반환 되면 응용 프로그램과 별도로 실행되는 백그라운드 작업을 남기지 않는다.
    
- SQLite DB는 디스크에 있는 단일 일반 파일(일반 디스크 파일)이다.
    
- DB엔진은 SQL 소스 코드를 실행 가능한 형식으로 컴파일하고 해당 실행 파일을 실행한 후 결과를 애플리케이션으로 다시 보낸다.
    
- SQLite 프로그램 컴파일 단계
    
    1. SQL 구문이 SQLite에 제공되면 맨 처음으로 하는 일은 소스 텍스트를 *토큰 으로 분할하는 일이다.
    2. 공백 및 주석은 버려지고, 다른 모든 토큰은 입력 프로그램의 구조를 분석하고, AST를 생성하는 LALR(1) 파서에 공급된다.
    3. 파서는 AST 생성 후 code-generator에 전달한다. code-generator는 SQLite의 핵심.
    4. code-generator는 AST의 기호 이름을 분석해 입력 SQL의 열 및 테이블 이름을 데이터베이스의 실제 열 및 테이블과 일치 시킨다.
    5. code-generator는 또한 AST를 최적화 하기 위해 다양한 변환을 수행하며
    6. 마지막으로 code-generator는 AST에서 요청한 작업을 구현하기 위해 적절한 알고리즘을 선택하고 작업을 수행하기 위한 바이트 코드를 구성한다.
    7. code-generator에 의해 생성된 bytecodes를 'prepared statement(준비된 명령문)' 라고 한다.
    8. 위의 과정을 통해 사람이 읽을 수 있는 소스 텍스트 (SQL or C++ 등)가 들어가고, 기계가 읽을 수 있는 실행 파일(바이트 코드 또는 기계어 코드)이 나온다.

<aside> 💡 * Token : 토큰 : 'SELECT', 'UPDATE' 와 같은 언어 키워드, 테이블이나 열, 변수 식별자, ', == ;' 등의 구두점 문자, 숫자 또는 문자열 상수 같은 리터럴 값, 공백 또는 주석

</aside>

- SQLite 바이트코드 엔진
    - SQLite는 SQL문을 바이트코드로 변환한 후, 가상 머신에서 해당 바이트코드를 실행하는 방식으로 동작한다.
    - SQLite는 SQL문을 바이트코드로 변환한 후, 가상 머신에서 해당 바이트코드를 실행하는 방식으로 동작한다.
    - 바이트코드 엔진은 SQLite의 API가 아니다.
    - 바이트코드 엔진에 대한 세부 내용은 업데이트에 따라 변경될 수 있다.
    - SQLite의 'prepared statement(준비된 명령문)' 은 대부분 해당 SQL을 구현하는데 필요한 바이트코드이다.
    - sqlite3_prepare_v2() 인터페이스는 SQL을 바이트코드로 변환하는 컴파일러다.
    - sqlite3_step() 인터페이스는 prepared statment 내에 포함된 바이트 코드를 실행하는 가상머신이다.
    - 보통 SQLite의 '바이트코드 엔진'은 '가상 DB 엔진' 또는 'VDBE'라고 한다.

---

1. 중요한 개념들
    
    - Big-endian : 낮은 주소에 데이터의 높은 바이트부터 저장하는 방식
        
        - 예를 들어, `0x12345678`의 32Bit 크기의 정수는
            
            `0x12`, `0x34`, `0x56`, `0x78` 와 같이 1Byte 값 4개로 구성된다
            
            이 4개의 1Byte 값을 Big-endian 방식으로 저장하면 아래 그림과 같다.
            
            ![[Untitled 11.png]]
            
        - 평소 숫자를 사용하는 방식인 선형 방식과 같다.
            
        - 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기 쉽다.
            
        - 데이터의 각 Byte를 배열처럼 취급하는 경우, 효율적이다.
            
    - Little-endian : 낮은 주소에 데이터의 낮은 바이트부터 저장하는 방식
        
        - 위의 예와는 반대로 저장이 되는 방식이다.
        ![[Untitled 12.png]]
        
        - 평소 사용하는 선형 방식과는 반대되는 개념이다.
        - 물리적으로 데이터 조작, 산술 연산을 수행하는 경우에 유리하다
    
    <aside> 💡 위의 두 방식은 단지 저장해야 할 큰 데이터를 어떻게 나누어 저장하는가 에 따른 차이일 뿐, 어느 것이 더 우수하다고 단정할 순 없다. ( [http://www.tcpschool.com/c/c_refer_endian](http://www.tcpschool.com/c/c_refer_endian) )
    
    </aside>
    
    <aside> 💡 메모리 구조 ( C )
    
    - 프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 load 되어야 한다
        
        또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다.
        
        따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있는데, 프로그램이 운영체제로부터 할당 받는 대표적인 메모리 공간은 다음과 같다.
        
        1. Code 영역
            
            실행할 프로그램의 코드가 저장되는 영역으로, 텍스트 영역으로 부르기도 한다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.
            
        2. Data 영역
            
            프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
            
        3. Stack 영역
            
            함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역. 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
            
            스택 영역에 저장되는 함수의 호출 정보를 스택 프레임이라고 한다.
            
            스택 영역은 push, pop으로 데이터를 저장/인출하며, 후입선출 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출된다. 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
            
        4. Heap 영역
            
            사용자가 직접 관리해야 하는 메모리 영역. 사용자에 의해 메모리 공간이 동적으로 할당되거나 해제되는 영역이다.
            
            메모리의 낮은 주소에서 높은 주소 방향으로 할당된다.
            
        
        ![[Untitled 13.png]]
        
    
    </aside>
    
    - Bit / byte : 컴퓨터는 모든 데이터를 2 진수로 표현 / 처리한다.
        
        - Bit : 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위,
            
            2 진수( 0 과 1 둘 중 하나만 저장 가능 )
            
        - Byte : Bit 8 개가 모여 구성되며, 문자 하나를 표현할 수 있는 최소 단위
            
        - Byte 저장 순서
            
            → 컴퓨터는 데이터를 메모리에 저장하는 경우, Byte 단위로 나눠서 저장한다. 하지만 컴퓨터가 저장하는 데이터는 대게 32Bit(4Byte) 혹은 64Bit(8Byte) 두 가지로 구성된다. 그렇기 때문에 연속되는 Byte를 순서대로 저장해야 하는데, 이 순서를 Byte 저장 순서라고 하며, 방식에 따라 Big/Little-endian 을 구분하게 된다.
            
    - 가변 길이 코드(Var int - Variable-Length Integer)
        
        - 압축하고자 하는 문자열에서 자주 등장하는 문자는 짧은 비트로 표현하고, 거의 등장하지 않는 문자는 긴 비트로 표현하는 방식.
            
        - 허프만 코드를 사용해 소스를 오류 없이 압축 및 해제(무 손실 데이터 압축) 할 수 있으며, 여전히 기호 별로 다시 읽을 수 있다.
            
        - 올바른 코딩 전략을 사용하면 독립적이고 동일하게 분산 된 소스를 거의 임의로 엔트로피에 가깝게 압축할 수 있다
            
        - 허프만 코드는 데이터를 효율적으로 사용하는 방법으로, 해당하는 순간에 가장 효율적인 방법을 택하는 탐욕 알고리즘 중 하나 이다.
            
        - 예를 들어, 압축하고자 하는 문자열이 ‘ABBCCCDDDDEEEEEFFFFFF’ 일 경우,
            
            → 고정 길이 코드의 경우 000001001010010010011011011011100100100100100101101101101101101
            
            → 가변 길이 코드의 경우
            
            100010011001101101101000000000101010101111111111111
            
            의 차이로, 허프만 코드를 사용한 가변 길이 코드가 더 짧다.
            
            ( [https://withhamit.tistory.com/12](https://withhamit.tistory.com/12) )
            

---

## File & Record Format

- SQLite 파일은 일련의 바이트 형식이다.
- ‘Page’ 라고 하는 동일한 크기의 청크로 나뉘며, 하나 이상의 페이지가 있을 수 있다.
    - 첫 페이지에서 파일에 대한 중요한 정보를 선언하기 때문에 첫 페이지가 가장 중요하다.
    - DB 파일의 처음 100byte는 데이터베이스 파일 헤더를 구성한다. DB 파일 헤더는 아래와 같이 Byte 기준 필드로 나뉘며, DB 파일 헤더의 모든 멀티바이트 필드는 최상위 바이트가 먼저 저장된다.( Big-endian 방식 )

| Byte 구간

|( 오프셋, 구간 )|레코드 형식|
|---|---|
|0, 16|모든 유효한 SQLite DB 파일은 16진수( 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00 )로 시작하며, 이 바이트 시퀀스는 끝에 null 종료 문자가 있다.|
|16, 2||
|DB 페이지 크기|3.7.1(2010-08-23) 이전에는 big-endian 정수로 해석되는 512 ~ 32768 사이의 2^n 값이었지만 3.7.1 이후에는 65536 Byte의 페이지 크기가 지원된다.|

값 65536은 2Byte 정수에 맞지 않으므로 65536Byte 페이지 크기를 지정하려면 오프셋 16의 값은 0x00 0x01 이다.

이 값은 big-endian 1로 해석할 수 있으며, 65536 페이지 크기를 나타내는 매직 넘버로 생각할 수 있다. 또는, 2바이트 필드를 small-endian 숫자로 보고 페이지 크기를 256으로 나눈 값이라고 말할 수 있다.

페이지 크기 필드에 대한 위 두 가지 해석은 동일하다. | | 18, 1 파일 형식 쓰기 버전 / 19, 1 파일 형식 읽기 버전 | 파일 형식 버전 번호. 향후 버전의 SQLite에서 파일 형식을 향상시킬 수 있도록 하기 위한 것이다.

SQLite 현재 버전에서 이 두 값은 *롤백 저널링 모드의 경우, 1이고, *WAL 저널링 모드의 경우 2이다.

현재 파일 형식 사양으로 코딩 된 SQlite 버전이 읽기 버전이 1 또는 2지만, 쓰기 버전이 2보다 큰 DB 파일을 만나면 DB 파일을 읽기 전용으로 처리해야 한다.

읽기 버전이 2보다 큰 DB파일이 있으면 해당 DB를 읽거나 쓸 수 없다. | | 20, 1 페이지 당 예약된 Byte | SQlite 는 확장에서 사용할 수 있도록 모든 페이지 끝에 약간의 추가 바이트를 따로 설정할 수 있는 기능이 있다. 예를 들어, SQLite 암호화 확장에서 각 페이지와 관련된 nonce 과(또는) 암호화 체크섬을 저장하는데 사용된다.

이러한 '예약된 공간' 크기는 확장을 위해 예약된 각 페이지의 끝에 있는 공간의 바이트 수 이다. 이 값은 일반적으로 0이며, 홀수일 수 있다.

DB 페이지의 '사용 가능한 크기' : 헤더의 오프셋 16에 있는 2바이트 정수로 지정된 페이지 크기에서 오프셋 20에 있는 1바이트 정수로 기록된 '예약된 공간'을 뺀 크기

사용 가능한 크기는 홀수일 수 있다. 그러나, 사용 가능한 크기는 480보다 작을 수 없다. 즉, 페이지 크기가 512이면 예약 공간 크기는 32를 초과할 수 없다. | | 21, 1 / 22, 1 / 23, 1 : 페이로드 비율 | 최대 및 최소 내장 페이로드 비율과 leaf 페이로드 비율 값은 64, 32, 32여야 한다. 이러한 값은 원래 B-Tree 알고리즘의 저장 형식을 수정하는데 사용할 수 있는 조정 가능한 매개변수로 사용되었으나 해당 기능은 지원되지 않으며, 지원을 추가 할 계획이 없다. 따라서, 이 3 바이트는 지정된 값으로 고정된다. | | 24, 4 파일 변경 카운터 | DB파일이 수정된 후 잠금이 해제될 때 마다 증가하는 Big-endian 정수.

둘 이상의 프로세스가 동일한 데이터베이스 파일을 읽고 있는 경우 각 프로세스는 변경 카운터를 모니터링 해 다른 프로세스의 DB변경사항을 감지할 수 있다.

프로세스는 일반적으로 캐시가 오래되었기 때문에 다른 프로세스가 DB를 수정할 때 DB 페이지 캐시를 플러시 하려고 한다. 파일 변경 카운터는 이를 용이하게 한다.

WAL 모드에서 DB변경은 wal-index를 사용해 감지되므로 변경 카운터가 필요하지 않다. 따라서, 변경 카운터는 WAL모드의 각 트랜잭션에서 증가하지 않을 수 있다. | | 28, 4 인헤더 DB 크기 | 오프셋 28의 4바이트 Big-endian 정수는 DB파일의 크기를 페이지 단위로 저장한다.

이 헤더 내 데이터 크기가 유효하지 않은 경우, DB 파일의 실제 크기를 확인해 DB 크기를 계산한다.

이전 버전의 SQLite는 헤더 내 DB크기를 무시하고 실제 파일 크기만 사용했다. 최신 버전의 경우, 가용 가능한 경우 헤더 내 DB 크기를 사용하지만, 헤더 내 DB 크기가 유효하지 않은 경우 실제 파일 크기로 대체된다.

인헤더 DB 크기는 0이 아닌, 오프셋 24의 변경 카운터와 오프셋 92의 버전 유효 숫자가 정확히 일치하는 경우 유효한 것으로 간주한다.

인헤더 DB 크기는 최신 3.7.0(2010-07-21) 이상 버전을 사용해 수정된 경우에만 유효하다.

레거시 버전의 SQLite가 DB에 기록하는 경우 인헤더 DB 크기 업데이트를 알지 못하므로 인헤더 DB 크기가 올바르지 않을 수 있다. 그러나 레거시 버전의 SQLite는 오프셋 92의 버전 유효 번호를 변경하지 않고 그대로 두어 변경 카운터와 일치하지 않게 해서 두 인자가 일치하지 않는 상황을 관찰해 감지(혹은 무시) 할 수 있다. | | 32, 4 : 사용되지 않는 페이지 목록 | 오프셋 32의 4바이트의 Big-endian 정수는 사용되지 않는 목록의 첫 번째 페이지의 페이지 번호를 저장하거나, 사용되지 않는 페이지 목록이 비어있으면 0을 저장한다.

DB 파일에서 사용되지 않은 페이지는 사용 가능 목록에 저장된다. | | 36, 4 | 오프셋 36의 4바이트 Big-endian 정수는 사용 가능한 목록의 총 페이지 수를 저장한다. | | 40, 4 : 스키마 쿠키 | DB 스키마가 변경될 때마다 증가하는 4바이트의 Big-endian 정수.

준비된 명령문은 DB 스키마의 특정 버전에 대해 컴파일 된다.|

DB 스키마가 변경되면 명령문을 다시 준비해야 한다.

준비된 명령문이 실행되면 먼저 스키마 쿠키를 확인한 값이 명령문이 준비되었을 때와 동일한지 확인하고, 스키마 쿠키가 변경 된 경우에는 명령문이 자동으로 다시 준비되고 실행되거나 SQLITE_SCHEMA 오류와 함께 중단된다. | | 44, 4 : 스키마 형식 번호 | 오프셋 44에 있는 4바이트 Big-endian 정수이다.

스키마 형식 번호는 오프셋 18, 19의 파일 형식 읽기 및 쓰기 버전 번호와 유사하지만 낮은 수준의 B-Tree 형식이 아닌, 높은 수준의 SQL 형식을 참조한다는 점이 다르다.

현재 4개의 스키마 형식 번호가 지정되어 있는데, SQLite에서 만든 새 DB 파일은 기본적으로 형식 4를 사용한다.

- 형식 4 : SQLite가 인덱스 선언에서 DESC 키워드를 존중하도록 한다.( DESC 키워드는 형식 1, 2 3의 인덱스에서 무시된다 ) 또한, 두개의 새로운 Boolean 레코드 유형 값을 추가한다.( 2006-01-10 SQLite 3.3.0 에 추가 )

형식 버전 번호는 컴파일타임에 SQLITE_DEFAULT_FILE_FORMAT = 1을 설정해 4 대신 1로 기본 설정할 수 있다. | | 48, 4 : 권장 캐시 크기 | 4 바이트의 Big-endian 부호 있는 정수.

DB파일의 페이지에서 제안된 캐시 크기이다.

이 값은 제안일 뿐, 강제되지는 않는다. 정수의 절댓값이 제안된 크기로 사용된다. | | 52, 4 / 64, 4 | 오프셋 52, 64에 있는 두개의 4바이트 Big-endian 정수. auto-vacuum / incremental-vacuum 모드를 관리하는 데 사용된다.

오프셋 52의 정수가 0이면, 포인터 맵(prtmap) 페이지가 DB 파일에서 생략되고 auto-vacuum과 incremental-vacuum 모두 지원되지 않는다.

오프셋 52의 정수가 0이 아니면, DB 파일에서 가장 큰 루트 페이지의 페이지 번호이며, DB 파일에는 ptrmap 페이지가 포함되어야 한다. 그리고 모드는 auto-vacuum 또는 incremental-vacuum 중 하나여야 한다.

후자의 경우, 오프셋 64의 정수는 incremental-vacuum에 대해 true이고, auto_incremental에 대해 false이다.

오프셋 52의 정수가 0이면, 오프셋 64의 정수도 0이어야 한다. | | 56, 4 : 텍스트 인코딩 | 4바이트 Big-endian 정수.

DB에 저장되는 모든 텍스트 문자열에 사용되는 인코딩을 결정한다. 1 : UTF-8 2 : UTF-16el 3 : UTF-16be 를 의미하며, 다른 값은 허용되지 않는다. | | 60, 4 : 사용자 버전 번호 | 4바이트 Big-endian 정수.

*user_version_pragma에 의해 설정, 쿼리 되는 사용자 버전 ( user_version_pragma : DB 헤더의 오프셋 60에서 사용자 버전 정수 값을 가져오거나 설정한다. 사용자 버전은 애플리케이션이 원하는 대호 사용할 수 있는 정수, SQLite는 사용자 버전 자체를 사용하지 않는다 )

사용자 버전은 SQLite에서 사용되지 않는다. | | 68, 4 : 애플리케이션 ID | 4바이트 Big-endian 정수.

DB가 특정 애플리케이션에 속하거나 연관되어 있음을 식별하기 위해 PRAGMA application_id 명령으로 설정할 수 있는 애플리케이션 ID.

애플리케이션 ID는 애플리케이션 파일 형식으로 사용되는 DB 파일에 저장된다.|

애플리케이션 ID는 단순히 'SQLite DB'를 기록하는 것보다 특정 파일 유형을 결정하기 위해 file(1)과 같은 유틸리티에서 사용할 수 있다.

할당 된 애플리케이션 ID 목록은 SQLite 소스 저장소 내부의 magic.txt 파일을 참조해 볼 수 있다. | | 96, 4 | 4바이트 Big-endian 정수, 가장 최근에 DB파일을 수정한 SQLite 라이브러리의 SQLITE_VERSION_NUMBER 값을 저장한다. | | 92, 4 | 4바이트 Big-endian 정수, 버전 번호가 저장되었을 때, 변경 카운터의 값이다. 오프셋 92의 정수는 버전 번호가 유효한 트랜잭션을 나타내며, '버전 유효 번호' 라고도 한다. | | 72, 20 | 확장을 위해 예약된 헤더 공간, DB파일 헤더의 다른 모든 바이트는 향후 확장을 위해 예약되어 있으며, 0으로 설정해야 한다. |

<aside> 💡 [https://www.sqlite.org/fileformat2.html](https://www.sqlite.org/fileformat2.html)

</aside>

<aside> 💡 파일 및 레코드 형식에 시작 ~ 오프셋 바이트 위치에 해당 자료들이 위치하는 이유

</aside>

---

- SQLite 외의 임베디드 데이터 베이스 ( [https://www.itworld.co.kr/news/117213](https://www.itworld.co.kr/news/117213) )
    
    - 아파치 더비 : 내장 가능한 SQL엔진이며, 오라클이 자바 DB로 리패키징 했다. 더비는 자바로 작성됐으며, JVM이 필요하므로 주로 자바 앱에 내장하는 용도로 적합하다
    - 파이어버드 임베디드 : 크로스 플랫폼이며, 많은 기능을 제공한다. 클라이언트 애플리케이션에 내장 가능한 라이브러리 형태로 제공된다.
    - 렐름 : 고성능 관계형 DB로, 모바일(주로 안드로이드)에 맞게 설계 되었지만, 윈도우와 같은 데스크톱 환경도 지원할 수 있다. 하지만 렐름은 객체 기반이며, SQL쿼리를 사용하지 않는다.
    - 비스타 DB : 닷넷 런타임용 내장 DB. 비스타 DB는 닷넷의 다양한 변형에 맞는 여러 버전으로 제공되며, 전체 데이터베이스 암호화와 같은 엔터프라이즈 기능을 다수 제공한다.
    - 버클리 DB : 오라클 프로젝트로, 명목상 키/값 저장소이지만 최근 버전에서는 SQL쿼리를 처리하기 위한 방편으로 SQLite를 사용한다. 여러 개의 동시 쓰기 작업을 처리하는 기능을 지원한다.
- 추가 개념 정리
    
    - **Payload** : 전송되는 데이터를 의미하며, 데이터 전송의 효율과 안정성을 높이기 위한 부가적인 정보를 제외한, 순수한 데이터 자체만을 일컫는다. 전송되는 json 데이터 내부에는 상태정보, from, 경로, method 방식에 대한 정보 등 수 많은 정보가 들어 있지만, 여기서 ‘payload’는 data만을 뜻하는 것이다.
        
    - **Offset** : 배열, 자료구조 오브젝트 내의 오프셋은 일반적으로 동일 프로젝트 안에서 오브젝트 처음부터 주어진 요소나 지점까지의 변위차를 나타내는 정수형이다. 예로, 문자 A의 배열이 'abcdef'를 포함한다면, 'c'는 A시작점에서 2의 오프셋을 지닌다고 할 수 있다. 오프셋을 이용해 주소를 나타내는 방식을 '상대주소 지정방식' 이라고도 표현 한다.
        
    - **Cache** : 자주 사용하는 데이터를 프로세서 내부에 미리 가져와 놓고, 메모리까지 접근하지 않고 사용할 수 있도록 함으로써 프로세서가 계속 바쁘게 돌아갈 수 있게 하는 기술 ( 자주 사용하는 데이터를 매번 메모리에 접근해 사용하면 오래 걸린다 )
        
        즉, 메모리에 접근하는 비용을 줄이는 기법 중 하나 → 프로세서 입장에서 캐시는 성능 개선 부분에서 굉장히 중요한 역할을 한다. → 프로세서의 성능은 빨라지는데 메모리가 그만큼 못 따라오니 시간이 지날수록 성능 차이가 커져 메워야 할 차이가 늘어간다 → 어플리케이션이 점점 더 많은 데이터를 사용하게 돼 이를 커버하기 위한 캐시의 크기가 커진다.
        
    - **변수와 메모리 구조** 변수는 기본적으로 메모리의 주소를 기억하는 역할을 한다. 메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자 역할, 메모리 공간 에서의 정확한 위치 식별을 위한 주소 변수를 참조할 때는 메모리의 주소가 아닌, 해당 주소에 저장 된 데이터를 참조하게 된다. 따라서 변수는 데이터가 저장된 메모리의 주소 뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 한다.
        
    - **트랜잭션의 특징 ( ACID )**
        
        - 원자성 ( Atomicity) : 트랜잭션이 DB에 모두 반영되던지, 아니면 전혀 반영되지 않아야 한다.
        - 일관성 ( Consistency )
            1. 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다
            2. 시스템이 가지고 있는 고정요소는 트랜잭션 전과 수행 완료 후의 상태가 같아야 한다
        - 독립성 ( Isolation )
            1. 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.
            2. 수행 중인 트랜잭션은 완전히 완료될 때 까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
        - 지속성 ( Durability ) : 트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영되어야 한다.
        
        ※ 트랜잭션은 꼭 필요한 최소의 코드에만 최소한의 범위의 코드에만 적용하는 것이 좋다.