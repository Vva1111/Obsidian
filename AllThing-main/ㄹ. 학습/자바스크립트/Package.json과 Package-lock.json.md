## Package.json
- 자바스크립트 프로젝트를 npm 패키지 저장소와 상호 작용할 수 있도록 만들어주는 연결 고리
- 이 파일을 통해 npm 패키지 저장소로부터 어떤 파일을 내려 받고, 설치해야 하는지, 또한 현재 프로젝트를 다른 프로젝트에서 사용할 수 있도록 어떻게 npm 패키지 저장소에 올릴 것 인지 설정할 수 있다.

	 **name & version**
	 - 해당 필드는 각 사용자들이 npm install 명령어로 해당 패키지를 설치할 때 사용할 패키지 이름과 버전을 명시한다.
	
	 **scripts**
	 - package.json 파일의 scripts 필드는 프로젝트에서 빈번하게 수행해야 하는 작업을 스크립트로 등록하기 위해 사용한다.
	 - 예를 들어, npm run / start / test ~ 명령어로 실행하는 스크립트를 이곳에 정의해 놓는다.
	 
	 **dependencies**
	 - 의존성 명시를 위한 필드
	 - 해당 프로젝트가 실행되기 위해 필수적으로 필요한 패키지들을 명시
	 
	 **devDependencied**
	 - 개발 의존성 - 테스트 혹은 빌드시에만 필요한 패키지들을 명시
	 
	 **peerDependencied**
	 - 라이브러리 개발의 경우, 해당 라이브러리에서 직접적으로 의존하진 않지만, 사용자 측에서 제대로 작동하려면 사용자가 다른 라이브러리를 설치해줘야 하는 경우가 있다.(대표적으로 다른 라이브러리를 보조/확장 하는 플러그인 혹은 애드온 류의 라이브러리)
	 - 위와 같은 경우에 peerDependencies 필드를 통해 반드시 같이 설치해줘야 하는 패키지를 명시할 수 있다.
	 - npm v7 부터는 peerDependencies 필드에 명시된 패키지도 자동으로 설치되도록 변경
	 
	 **private**
	 - 프로젝트가 npm 패키지 저장소로 발행(publish)해도 되는지 여부를 지정하기 위해 사용
	 - 이 필드의 기본 값은 fasle이기 때문에 따로 명시해주지 않으면 프로젝트가 npm 패키지 저장소로 업로드될 수 있으므로, 저장소에 올리면 안되는 프로젝트의 경우 반드시 true 값으로 설정해줘야 한다
	 
	 **homepage & repository**
	 - **homepage** 옵션에는 해당 프로젝트의 홈페이지나 문서 페이지의 URL을 설정할 수 있다.
		 *npm docs* 명령어를 실행해 해당 URL을 열어볼 수 있다.
	 - **repository** 옵션에는 해당 프로젝트의 코드 저장소의 URL을 설정할 수 있다.
		 *npm repo* 명령어를 실행해 URL을 열어볼 수 있다.
	- 위 두 옵션은 특히 npm 패키지 저장소에 프로젝트를 발행할 때 상당히 중요한데, npm 웹사이트에서 패키지 상세 페이지에 들어가면 위 두개의 URL이 링크되기 때문이다.
	
	 **license**
	 - 해당 프로젝트의 라이선스 표시
	
	 **author & contributors**
	 - 해당 프로젝트의 저자 / 공헌자
	 - 옵션 내부에 프로퍼티 값으로 이름, 메일, url을 입력할 수 있다.
	 
	 **main**
	 - 해당 패키지를 npm에서 설치해 사용할 때 프로젝트 내에 어떤 파일이 불러와질지 결정하는 중요한 필드
	 - 명시하지 않았을 경우, 기본적으로 프로젝트의 최상위 디렉토리에 있는 index.js 파일이 사용된다.
	 - 사용자가 import한 패키지가 있다면, 해당 프로젝트의 최상위 디렉토리에 있는 index.js 파일에서 내보내기(export)를 하는 함수 혹은 클래스가 불러와 질 것이다.
	 - 하지만 요즘은 프로젝트의 소스 코드를 직접 발행하기 보다는 babel과 같은 transpiler 혹은 Webpack과 같은 bundler를 사용하는 경우가 많기 때문에 소스 파일 대신 프로젝트 빌드 결과물이 생성되는 디렉토리 내에 파일을 main 필드로 지정해줘야 한다.
	 
	 **type & module**
	 - type 필드를 "module"로 설정하면 해당 프로젝트에서는 CommonJS 대신 ES Module을 사용하게 된다.
	 - 만약 해당 프로젝트를 npm 패키지 저장소에 발행한다면 module 필드를 통해 사용자가 패키지를 불러올 때 사용되어야 하는 mjs 파일을 명시해줘야 한다.
	 
	 **types**
	 - 타입스크립트로 개발하고 자바스크립트로 컴파일한 후 발행하는 프로젝트의 경우, 해당 프로젝트에서 정의하고 있는 타입 정보를 담고 있는 파일의 위치를 types 필드를 통해 지정해줄 수 있다.
	 
	 **files**
	 - npm에 패키지를 발행할 때는 기본적으로 프로젝트 내의 모든 파일이 포함되는데, 만약 프로젝트 내의 특정 파일만 발행시킬 패키지에 포함하고 싶다면 files 필드를 통해 명시할 수 있다.
	 - 예를 들어, 타입스크립트로 작성된 소스 코드를 제외하고 최종 컴파일 된 자바스크립트 코드만 패키지에 포함하고 싶다면 *"files: ["dist]"* 와 같이 필드를 지정할 수 있다.
	 - 이 필드는 패키지의 크기를 줄이는 데 사용할 수 있다.
	 
	 **overides**
	 - 프로젝트의 의존성 트리 내에서 특정 패키지의 버전을 덮어쓸 수 있도록 해준다.
	 - 보통 보안적인 이유로 특정 패키지의 버전을 강제로 고정하거나 업데이트를 방지하고 싶을 때 유용하게 사용할 수 있다.
	 
	 **publishConfig**
	 - npm 패키지 저장소에 발행할 때 필요한 설정을 담아두는 필드
	 - 예를 들어, registry 설정에 github package 저장소 URL을 설정해둔다면 외부 패키지를 설치할 때는 npm 패키지 저장소를 사용하지만, 해당 프로젝트를 발행할 때는 github 패키지 저장소를 사용하게 된다.
	 
	 **비표준 필드**
	 - 많은 자바스크립트 도구들이 package.json 파일의 특정 필드를 통해 설정을 가능하도록 지원하고 있다.
	 - 예를 들어, prettier 포맷터는 prettier 필드를 통해 설정할 수 있고, ESLint는 eslintConfig 필드를 통해 설정하고, Babel 트랜스파일러는 babel 필드를 통해 설정할 수 있다.
```json
{
  "prettier": {
    "singleQuote": true
  },
  "eslintConfig": {
    "extends": ["react-app", "react-app/jest"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```



## Package-lock.json
#### Package Manager
- 패키지를 프로젝트에 설치하거나 갱신 또는 삭제하는데 사용되는 도구
- npm / yarn 두 가지가 현재는 대표적으로 사용
- 이러한 패키지 매니저는 모두 패키지 잠금 파일을 지원한다.

#### 패키지 관리 매커니즘
- 어떠한 패키지 매니저를 사용하든 해당 프로젝트의 메타 정보는 package.json 파일을 통해 관리된다.
- package.json 파일에는 해당 프로젝트가 의존하고 있는 모든 패키지 이름과 버전이 나열되어 있음
- 일반적으로 설치되어야 하는 패키지들은 **dependencies** 항목에 명시
- 개발 시에만 필요한 패키지들은 **devDependencies** 항목에 명시
- 설치가 필요한 패키지들이 package.json 에 등록되어 있으면, 프로젝트의 모든 개발자는 패키지 매니저의 설치 커맨드 하나로 모든 패키지를 한번에 설치할 수 있다.
- 설치 커맨드를 실행 시, package.json 파일에 등록되어 있는 모든 패키지가 npm registry로부터 다운받아져 node_modules 디렉토리에 저장 된다.
- 패키지의 버전 같은 경우, 특별히 명시되어 있지 않은 이상, 설치 시점의 최신 버전을 가져오기 때문에 특정한 버전의 설치만을 원할 경우, 명시가 필요하다.
- 사람이 직접 버전의 범위를 명시할 경우, 실수나 악의적인 의도가 포함될 수 있기 때문에 보안 문제가 발생할 가능성도 있다. 
	- 위와 같이 npm 패키지 저장소와 같은 소프트웨어 패키지나 라이브러리의 공급망을 통해 공격하는 것을 supply-chain attack 이라고 한다.
- 위와 같이 동일한 package.json 파일을 사용해도 시간 혹은 장소에 따라 서로 다른 버전의 패키지가 설치되는 문제를 package-lock.json 파일을 통해 해결할 수 있다.
	- package-lock.json 와 같은 패키지 잠금 파일에는 해당 프로젝트에서 각 패키지가 **최초 설치될 당시** 정확히 어떤 버전이었는지 기록된다.
	- 프로젝트 최초의 npm install 기준으로 설치된 버전을 기준으로 package-lock.json 파일이 생성된다.
	- 이후 git에 업데이트 된 package-lock.json 에 명시된 버전을 기준으로 install 을 실행하기 때문에 항상 같은 버전의 패키지가 설치되는 것을 보장 받을 수 있다.

#### 주의사항
- 프로젝트를 최초 셋업하는 개발자는 git에 package-lock.json 파일을 올려 다른 개발자들도 lock 파일을 참조해서 패키지를 설치할 수 있도록 해야 한다.
- lock 파일은 패키지 매니저가 신규 패키지를 설치하거나 기존 패키지를 갱신/제거할 때 마다 package.json과 자동으로 동기를 맞춰주기 때문에 개발자는 lock 파일을 직접 수정할 일이 없으며, 수정이 권장되지도 않는다.
- 패키지 업데이트의 경우, package.json 파일과 package-lock.json 을 함께 올려야 한다.