[자바스크립트 프레임워크 하이드레이션](https://dev.to/this-is-learning/why-efficient-hydration-in-javascript-frameworks-is-so-challenging-1ca3) 해석

1. 서버가 초기 HTML을 생성하면, 그 결과에 이벤트 핸들러를 붙이고 브라우저에서 인터랙티브하게 동작하도록 애플리케이션 상태를 초기화해야 한다.
2. 대부분의 프레임워크에서 하이드레이션은 페이지를 처음 로드할 때 상당히 큰 비용을 수반한다.

#### 서버사이드 렌더링이 만능은 아니다.
- 단순히 서버가 Single Page App을 렌더링한다고 SEO, 성능 모든 면에서 항상 좋은 결과를 가져온다고 기대할 수 없다.
- **오히려 자바스크립트 코드를 증가시키며**
	- 대부분의 프레임워크에서 하이드레이션 준비 코드는 궁극적으로 두 가지 작업을 모두 수행해야 하기 때문에 일반적인 클라이언트 코드보다 크다.
	- 처음에는 하이드레이션만 할지라도, 클라이언트 측 렌더링을 허용하기 때문에 그것을 위한 코드도 필요하다.
- **애플리케이션이 인터랙티브 할 때까지 걸리는 시간이 단순 클라이언트 렌더링보다 더 길어질수도 있다.**
	- 데이터를 로드할 때 사용자에게 보여줄 수 있는 HTML 페이지를 보여주는 대신, 서버에서 전체 페이지가 로드되고 렌더링될 때까지 기다려야 한다.
	- 또한, 그 페이지는 모든 HTML과 애플리케이션이 부트스트랩에 필요한 데이터를 포함하고 있기 때문에 훨씬 크다.
	- 물론, 나쁜 점만 있는 것은 아니다. 
	- 일반적으로는 브라우저가 자바스크립트를 로드하기 위한 추가 왕복 시간을 기다릴 필요가 없기 때문에 메인 콘텐츠가 더 빨리 보이게 된다.
	- 하지만 이 또한 애플리케이션을 하이드레이션 하기 위한 자바스크립트를 포함하고 있는 애셋의 로딩을 지연시킨다.
	- **이는 사용자 네트워크와 데이터 지연 시간에 크게 좌우된다. 스트리밍과 같이 로드 성능 타이밍을 해결하기 위한 많은 기술이 있지만, 이는 명백한 해결책은 아니며, 새로운 트레이드 오프와 고려사항이 있다.

#### 근본적인 문제
- **클라이언트측 하이드레이션의 단점
	- 서버에서 렌더링을 한 후, 브라우저에서 하이드레이션을 하기 위해 또 다시 렌더링 해야 한다는 점
	- 모든 것을 HTML로 한 번, 자바스크립트로 또 한 번, 총 두 번 전송한다는 점
- **일반적으로 아래 3가지 형태로 전송된다**
	- 템플릿 - 컴포넌트 코드 / 정적 템플릿
		-> 번들된 자바스크립트와 렌더링된 HTML, 두 가지 모두에 포함되어 있으며, 데이터도 페이지에 렌더링된 스크립트 태그와 최종 HTML의 일부, 두 가지에 모두 표시된다.
	- 데이터 - 템플릿을 채우기 위한 데이터
		-> 클라이언트 렌더링의 경우, 템플릿을 보내고 렌더링할 데이터를 요청한다. 중복은 없지만 무언가를 표시하려면 자바스크립트 번들을 로드하는 네트워크를 기다릴 수 밖에 없다.
	- 구현된 뷰 - 최종 HTML
- 서버에서 구현된 HTML을 사용하면 서버 렌더링의 이점을 얻을 수 있고, 이는 사이트를 표시하는데 있어 자바스크립트 로딩 시간에 구애받지 않게 해준다. 하지만, 서버사이드 렌더링 또한 추가적인 비용이 존재한다.

#### 정적 라우팅(하이드레이션 없음)
- 여러 SSR 프레임워크에서 채택된 아이디어 중 하나는 일부 페이지에서 \<script> 태그를 제거하는 기능이다. 이 페이지들은 정적이고, 자바스크립트가 필요하지 않다.
- 이 접근 방식은 SSR을 통해 항상 가능했지만, 유연하지 못하기 때문에 해결책이 될 순 없다.


#### 자바스크립트 레이지로딩(점진적 하이드레이션)
- 자바스크립트를 바로 로드하지 않고 인터렉션에 따라 로드하는 것을 말한다.
- 마우스 클릭, 이동, 스크롤 등의 인터렉션에 따라 로드하는 방식
- 인터렉션이 없다면 아예 자바스크립트를 보내지 않을 수도 있지만, 여기에도 문제점은 있다.
- 대부분의 자바스크립트 프레임워크는 하향식 하이드레이션을 한다. 따라서, 애플리케이션에(단일 페이지 애플리케이션 처럼) 공통 루트가 포함되어 있는 경우 이를 로드해야 한다.
- 그리고 렌더 트리가 너무 얕지 않다면 화면의 중간 버튼을 클릭했을 때, 엄청난 양의 코드를 로드하고 하이드레이션 해야 한다.
- 사용자가 무언가를 할 때까지 오버헤드를 미루는 것은 좋지 않다.
- 따라서, 넓고 얕은 트리가 있는 애플리케이션에서는 도움이 될 수 있겠지만, 최신 SPA에서는 그렇지 않다. 클라이언트 측 라우팅, 컨텍스트 제공자 및 경계 컴포넌트(서스펜스, 에러 또는 기타)등의 패턴으로 인해 깊은 트리가 만들어지기 때문이다.
- 이 방법만으로는 사용할 수 있는 모든 데이터를 직렬화하는 것을 막을 수 없다. 결국 무엇이 로드될지 모르기 때문에 모든 것을 사용할 수 있어야 한다.

#### HTML에서 데이터 추출
- 렌더링 된 HTML에서 상태를 리버스 엔지니어링 하는 방식
- 큰 JSON blob을 보내는 대신 HTML에 삽입된 값으로부터 상태를 초기화한다.
- 문제는 보델과 뷰가 할상 1:1로 대응되지 않는다는 것이다.


#### 부분 하이드레이션
- 전체 웹 페이지 중에서 사용자가 인터렉션 할 수 있는 몇몇 부분만 하이드리레이션 하는 방식
- 이러한 방식의 애플리케이션에서는 인풋 또는 프로퍼티를 최상위 컴포넌트에 직렬화하기만 하면 된다.
- 더 상위에 상태를 저장하고 있는 것이 없다는 것을 알고 있기 때문에 상위 레벨에서의 리렌더링은 절대로 일어나지 않는다.
- 따라서 단순히 사용하지 않는 데이터를 보내지 않는 것만으로도 이중 데이터 문제를 많이 해결할 수 있다.
- 이 방식은 정적 라우팅에서 사용하는 기능에 대해서만 비용이 발생하도록 개선된 버전이다.

#### 순서가 뒤바뀐 하이드레이션
- 레이지로딩의 개선된 버전
- 하이드레이션이 일반적인 하향식 렌더링 프레임워크에 의해 제한되지 않는다면, 화면 중간 버튼의 하이드레이션이 컴포넌트 계층의 상위에 있는 클라이언트 라우팅과 상태 관리 로직을 로딩하는 것과 상관 없이 가능해진다.
- 하지만 이 방법은 우리에게 익숙한 부모, 자식 상호 작용의 규칙들이 조정되고 제한될 필요가 있기 때문에 익숙하지 않은 방식으로 개발되게 된다.
- 또한 이 방식은 레이지 로딩과 마찬가지로 데이터 중복을 줄일 수 없다. 어떤 컴포넌트를 실제로 부라우저로 전송해야 하는지 알 수 없기 때문이다.

#### 서버 컴포넌트
- 부분 하이드레이션 적용 후, 서버에서 정적인 부분을 다시 렌더링하는 방식을 사용하려면 서버 컴포넌트가 필요하다
- 컴포넌트 크기가 줄어들고, 중복 데이터가 제거되므로 부분 하이드레이션의 많은 이점을 가져가면서, 네비게이션 시 클라이언트 측 상태를 유지하는 것도 포기하지 않을 수 있다.